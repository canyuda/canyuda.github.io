<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JetCache的源码 | 灿若繁星</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1$ git clone git@github.com:alibaba&#x2F;jetcache.git">
<meta property="og:type" content="article">
<meta property="og:title" content="JetCache的源码">
<meta property="og:url" content="http://blog.canyuda.top/posts/2021040542562/index.html">
<meta property="og:site_name" content="灿若繁星">
<meta property="og:description" content="1$ git clone git@github.com:alibaba&#x2F;jetcache.git">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224344.png">
<meta property="og:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224436.png">
<meta property="og:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224459.png">
<meta property="og:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224543.png">
<meta property="og:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224626.png">
<meta property="article:published_time" content="2021-04-05T12:57:40.000Z">
<meta property="article:modified_time" content="2022-11-19T10:40:57.772Z">
<meta property="article:author" content="灿若繁星先生">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224344.png">
  
    <link rel="alternate" href="/atom.xml" title="灿若繁星" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">灿若繁星</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人空间</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.canyuda.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2021-04-JetCache的源码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/2021040542562/" class="article-date">
  <time class="dt-published" datetime="2021-04-05T12:57:40.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JetCache的源码
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:alibaba/jetcache.git</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache接口定义和一些了的新增, 插入, 移除等操作方法, 除此之外还有tryLock方法的默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> AutoReleaseLock <span class="title function_">tryLock</span><span class="params">(K key, <span class="type">long</span> expire, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">expireTimestamp</span> <span class="operator">=</span> System.currentTimeMillis() + timeUnit.toMillis(expire);</span><br><span class="line">    <span class="comment">// 配置有些阈值要用其判断循环次数.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CacheConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="comment">// 实现AutoReleaseLock的解锁操作, 是通过缓存来实现的锁</span></span><br><span class="line">    <span class="type">AutoReleaseLock</span> <span class="variable">lock</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unlockCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (unlockCount++ &lt; config.getTryLockUnlockCount()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(System.currentTimeMillis() &lt; expireTimestamp) &#123;</span><br><span class="line">                <span class="comment">// 锁未过期时, 尝试移除锁</span></span><br><span class="line">                <span class="type">CacheResult</span> <span class="variable">unlockResult</span> <span class="operator">=</span> REMOVE(key);</span><br><span class="line">                <span class="keyword">if</span> (unlockResult.getResultCode() == CacheResultCode.FAIL</span><br><span class="line">                        || unlockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">// 失败和半成功都需要重试</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlockResult.isSuccess()) &#123;</span><br><span class="line">                    <span class="comment">// 锁移除成功</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// NOT_EXISTS, EXISTS, EXPIRED 等状态为异常状态, 兜底直接解</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超时了直接解锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 加锁操作, 是通过缓存来实现的锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lockCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 循环尝试加锁, 配置中包含阈值</span></span><br><span class="line">    <span class="keyword">while</span> (lockCount++ &lt; config.getTryLockLockCount()) &#123;</span><br><span class="line">        <span class="type">CacheResult</span> <span class="variable">lockResult</span> <span class="operator">=</span> cache.PUT_IF_ABSENT(key, uuid, expire, timeUnit);</span><br><span class="line">        <span class="keyword">if</span> (lockResult.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 成功向缓存插入记录, 即获取了锁</span></span><br><span class="line">            <span class="keyword">return</span> lock;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lockResult.getResultCode() == CacheResultCode.FAIL || lockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 失败或者半成功</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">inquiryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (inquiryCount++ &lt; config.getTryLockInquiryCount()) &#123;</span><br><span class="line">                <span class="comment">// 循环查询刚刚put的锁, 等待加锁完成</span></span><br><span class="line">                <span class="type">CacheGetResult</span> <span class="variable">inquiryResult</span> <span class="operator">=</span> cache.GET(key);</span><br><span class="line">                <span class="keyword">if</span> (inquiryResult.isSuccess()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (uuid.equals(inquiryResult.getValue())) &#123;</span><br><span class="line">                        <span class="comment">// 查询加锁成功并且uuid和当前线程生成的一毛一样, 表示是自己刚刚put的锁.</span></span><br><span class="line">                        <span class="keyword">return</span> lock;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 查询加锁成功,但是内部的value不是自己生成的, 这个说不是自己刚刚put的.</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 配置的阈值范围内, 循环验证刚加的锁是否成功.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他方控制了锁, 返回未获取到锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractCache"><a href="#AbstractCache" class="headerlink" title="AbstractCache"></a>AbstractCache</h3><blockquote>
<p>使用了模板方法模式, 实现了Cache接口, 支持了各种事件发布的功能(CacheEvent的实现), 并且对外暴露abstract方法, 供不同Cache实现自己的新增, 插入, 移除等操作</p>
</blockquote>
<p>实现了同步加载的静态方法<code>synchronizedLoad</code>, 目的是为了支持<code>computeIfAbsent</code>的逻辑, <code>computeIfAbsent</code>会在查找缓存不到的时候, 自动执行load, 但是会有缓存穿透的风险, 大量请求可能导致一些问题(load操作很耗资源的情况下)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持computeIfAbsent方法</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; V <span class="title function_">computeIfAbsentImpl</span><span class="params">(K key, Function&lt;K, V&gt; loader, <span class="type">boolean</span> cacheNullWhenLoaderReturnNull,</span></span><br><span class="line"><span class="params">                                            <span class="type">long</span> expireAfterWrite, TimeUnit timeUnit, Cache&lt;K, V&gt; cache)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是个强转型</span></span><br><span class="line">    AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">    <span class="comment">// 使用了函数式接口, 并使用了代理模式，创建了一个缓存load代理对象，用于记录load耗时</span></span><br><span class="line">    CacheLoader&lt;K, V&gt; newLoader = CacheUtil.createProxyLoader(cache, loader, abstractCache::notify);</span><br><span class="line">    CacheGetResult&lt;V&gt; r;</span><br><span class="line">    <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> RefreshCache) &#123;</span><br><span class="line">        <span class="comment">// RefreshCache暂时不看</span></span><br><span class="line">        RefreshCache&lt;K, V&gt; refreshCache = ((RefreshCache&lt;K, V&gt;) cache);</span><br><span class="line">        r = refreshCache.GET(key);</span><br><span class="line">        refreshCache.addOrUpdateRefreshTask(key, newLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取一个CacheGetResult</span></span><br><span class="line">        r = cache.GET(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 成功直接返回</span></span><br><span class="line">        <span class="keyword">return</span> r.getValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不成功需要load</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义插入缓存的Consumer</span></span><br><span class="line">        Consumer&lt;V&gt; cacheUpdater = (loadedValue) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(needUpdate(loadedValue, cacheNullWhenLoaderReturnNull, newLoader)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeUnit != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cache.PUT(key, loadedValue, expireAfterWrite, timeUnit).waitForResult();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache.PUT(key, loadedValue).waitForResult();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        V loadedValue;</span><br><span class="line">        <span class="comment">// 根据配置判断是否需要防穿透</span></span><br><span class="line">        <span class="keyword">if</span> (cache.config().isCachePenetrationProtect()) &#123;</span><br><span class="line">            loadedValue = synchronizedLoad(cache.config(), abstractCache, key, newLoader, cacheUpdater);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不防, 先loader出数据, 然后更新缓存</span></span><br><span class="line">            loadedValue = newLoader.apply(key);</span><br><span class="line">            cacheUpdater.accept(loadedValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步load</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; V <span class="title function_">synchronizedLoad</span><span class="params">(CacheConfig config, AbstractCache&lt;K,V&gt; abstractCache,</span></span><br><span class="line"><span class="params">                                    K key, Function&lt;K, V&gt; newLoader, Consumer&lt;V&gt; cacheUpdater)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取一个ConcurrentHashMap的单例对象</span></span><br><span class="line">    ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap = abstractCache.initOrGetLoaderMap();</span><br><span class="line">    <span class="comment">// key可用自定义keyConvertor</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lockKey</span> <span class="operator">=</span> buildLoaderLockKey(abstractCache, key);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组标记位, 记录是否被创建</span></span><br><span class="line">        <span class="type">boolean</span> create[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 往loaderMap尝试插入, 插入成功标记为为true</span></span><br><span class="line"><span class="type">LoaderLock</span> <span class="variable">ll</span> <span class="operator">=</span> loaderMap.computeIfAbsent(lockKey, (unusedKey) -&gt; &#123;</span><br><span class="line">            create[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">LoaderLock</span> <span class="variable">loaderLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoaderLock</span>();</span><br><span class="line">            <span class="comment">// LoaderLock对象中有个CountDownLatch, 并记录了当前线程</span></span><br><span class="line">            loaderLock.signal = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            loaderLock.loaderThread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">return</span> loaderLock;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果标记物为true, 或者LoaderLock对象存在, 创建者是本线程, 即支持重入.</span></span><br><span class="line">        <span class="keyword">if</span> (create[<span class="number">0</span>] || ll.loaderThread == Thread.currentThread()) &#123;</span><br><span class="line">            <span class="comment">// 执行load</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">loadedValue</span> <span class="operator">=</span> newLoader.apply(key);</span><br><span class="line">                ll.success = <span class="literal">true</span>;</span><br><span class="line">                ll.value = loadedValue;</span><br><span class="line">                <span class="comment">// 让传入的cacheUpdater更新缓存</span></span><br><span class="line">                cacheUpdater.accept(loadedValue);</span><br><span class="line">                <span class="keyword">return</span> loadedValue;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果loaderMap的写入者是自己,释放资源</span></span><br><span class="line">                <span class="keyword">if</span> (create[<span class="number">0</span>]) &#123;</span><br><span class="line">                    ll.signal.countDown();</span><br><span class="line">                    loaderMap.remove(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果创建者不是自己, 并且LoaderLock对象不做当前线程所创建的</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 查配置,穿透保护的超时时间, 选择使用哪种await方法来等待</span></span><br><span class="line">                <span class="type">Duration</span> <span class="variable">timeout</span> <span class="operator">=</span> config.getPenetrationProtectTimeout();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没有则永久等待</span></span><br><span class="line">                    ll.signal.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 有时间的等待</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> ll.signal.await(timeout.toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">                        <span class="comment">// 等待CountDownLatch计时结束, 如果时间过了, ll.signal.countDown();还没被调用, 证明是loader太久了, 当前线程就等不及了开始load</span></span><br><span class="line">                        <span class="keyword">return</span> newLoader.apply(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 等待被中断也等不及, 当前线程马上load</span></span><br><span class="line">                <span class="keyword">return</span> newLoader.apply(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查看ConcurrentHashMap中的LoaderLock中的标记是否成功, 成功表示load完成, 返回LoaderLock对象中的结果, 否则继续下一波循环.</span></span><br><span class="line">            <span class="keyword">if</span> (ll.success) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V) ll.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractEmbeddedCache"><a href="#AbstractEmbeddedCache" class="headerlink" title="AbstractEmbeddedCache"></a>AbstractEmbeddedCache</h4><blockquote>
<p>继承自AbstractCache, 加了个InnerMap的成员变量, InnerMap属于适配器模式, 用来屏蔽不同本地缓存的差异性(jetcache目前提供了LinkedHashMapCache和CaffeineCache,如果用的不爽可以自定义一个缓存集合,用InnerMap来适配一下增删改查等方法)</p>
</blockquote>
<p>并且AbstractEmbeddedCache引入了CacheValueHolder, 是对缓存中value的包装, 其中包含了过期时间.</p>
<h5 id="CaffeineCache"><a href="#CaffeineCache" class="headerlink" title="CaffeineCache"></a>CaffeineCache</h5><blockquote>
<p>基于内存的缓存，使用Caffeine</p>
</blockquote>
<p>需要引入:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Caffeine在算法上对本地缓存做了优化, 缓存性能接近理论最优, 采用了一种结合LRU、LFU优点的算法：W-TinyLFU</p>
<blockquote>
<p>TinyLfu 回收策略，提供了一个近乎最佳的命中率。当数据的访问模式不随时间变化的时候，LFU的策略能够带来最佳的缓存命中率。然而LFU有两个缺点：首先，它需要给每个记录项维护频率信息，每次访问都需要更新，这是个巨大的开销；其次，如果数据访问模式随时间有变，LFU的频率信息无法随之变化，因此早先频繁访问的记录可能会占据缓存，而后期访问较多的记录则无法被命中。因此，大多数的缓存设计都是基于LRU或者其变种来进行的。相比之下，LRU并不需要维护昂贵的缓存记录元信息，同时也能够反应随时间变化的数据访问模式。然而，在许多负载之下，LRU依然需要更多的空间才能做到跟,FU一致的缓存命中率。因此，一个“现代”的缓存，应当能够综合两者的长处。TinyLFU维护了近期访问记录的频率信息，作为一个过滤器，当新记录来时，只有满足TinyLFU要求的记录才可以被插入缓存。</p>
</blockquote>
<h5 id="LinkedHashMapCache"><a href="#LinkedHashMapCache" class="headerlink" title="LinkedHashMapCache"></a>LinkedHashMapCache</h5><blockquote>
<p>自制的简易内存缓存，没有任何依赖</p>
</blockquote>
<p>使用LinkedHashMap实现了一个LRUMap, 缓存过期依赖于Cleaner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cleaner</span> &#123;</span><br><span class="line">    <span class="comment">// 内部一个LinkedList,保存每一个LinkedHashMapCache的弱引用</span></span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; linkedHashMapCaches = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> JetCacheExecutor.defaultExecutor();</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; run(), <span class="number">60</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(LinkedHashMapCache cache)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (linkedHashMapCaches) &#123;</span><br><span class="line">            linkedHashMapCaches.add(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(cache));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (linkedHashMapCaches) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个Cache, 执行Cache的cleanExpiredEntry来做定时过期</span></span><br><span class="line">            Iterator&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; it = linkedHashMapCaches.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                WeakReference&lt;LinkedHashMapCache&gt; ref = it.next();</span><br><span class="line">                <span class="type">LinkedHashMapCache</span> <span class="variable">c</span> <span class="operator">=</span> ref.get();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c.cleanExpiredEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractExternalCache"><a href="#AbstractExternalCache" class="headerlink" title="AbstractExternalCache"></a>AbstractExternalCache</h4><p>外部存储的抽象, 由于是外部的存储, 所以涉及到Value的序列化和反序列化</p>
<h5 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h5><blockquote>
<p>redis实现，使用jedis客户端</p>
</blockquote>
<p>RedisCache可以做读写分离, 并且可以设置每个slave节点的权重, 相关代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedisCache的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(RedisCacheConfig&lt;K, V&gt; config)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(config);</span><br><span class="line">    <span class="built_in">this</span>.config = config;</span><br><span class="line">    <span class="built_in">this</span>.valueEncoder = config.getValueEncoder();</span><br><span class="line">    <span class="built_in">this</span>.valueDecoder = config.getValueDecoder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.getJedisPool() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheConfigException</span>(<span class="string">&quot;no pool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意下面config中的配置对其影响</span></span><br><span class="line">    <span class="keyword">if</span> (config.isReadFromSlave()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.getJedisSlavePools() == <span class="literal">null</span> || config.getJedisSlavePools().length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheConfigException</span>(<span class="string">&quot;slaves not config&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (config.getSlaveReadWeights() == <span class="literal">null</span>) &#123;</span><br><span class="line">            initDefaultWeights(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.getSlaveReadWeights().length != config.getJedisSlavePools().length) &#123;</span><br><span class="line">            initDefaultWeights(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.isExpireAfterAccess()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheConfigException</span>(<span class="string">&quot;expireAfterAccess is not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化默认权重</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDefaultWeights</span><span class="params">(RedisCacheConfig&lt;K, V&gt; config)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> config.getJedisSlavePools().length;</span><br><span class="line">    <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    Arrays.fill(weights, <span class="number">100</span>);</span><br><span class="line">    config.setSlaveReadWeights(weights);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取读节点</span></span><br><span class="line">Pool&lt;Jedis&gt; <span class="title function_">getReadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!config.isReadFromSlave()) &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getJedisPool();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] weights = config.getSlaveReadWeights();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> randomIndex(weights);</span><br><span class="line">    <span class="keyword">return</span> config.getJedisSlavePools()[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据权重来</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomIndex</span><span class="params">(<span class="type">int</span>[] weights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sumOfWeights</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : weights) &#123;</span><br><span class="line">        sumOfWeights += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> random.nextInt(sumOfWeights);</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">        x += weights[i];</span><br><span class="line">        <span class="keyword">if</span>(r &lt; x)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheException</span>(<span class="string">&quot;assert false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 批量插入操作使用了redis的Pipeline</span></span><br><span class="line"><span class="keyword">protected</span> CacheResult <span class="title function_">do_PUT_ALL</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map, <span class="type">long</span> expireAfterWrite, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> config.getJedisPool().getResource()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">failCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Response&lt;String&gt;&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// Pipeline</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">p</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; en : map.entrySet()) &#123;</span><br><span class="line">            CacheValueHolder&lt;V&gt; holder = <span class="keyword">new</span> <span class="title class_">CacheValueHolder</span>(en.getValue(), timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">            Response&lt;String&gt; resp = p.psetex(buildKey(en.getKey()), timeUnit.toMillis(expireAfterWrite), valueEncoder.apply(holder));</span><br><span class="line">            responses.add(resp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步</span></span><br><span class="line">        p.sync();</span><br><span class="line">        <span class="keyword">for</span> (Response&lt;String&gt; resp : responses) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="string">&quot;OK&quot;</span>.equals(resp.get()))&#123;</span><br><span class="line">                failCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> failCount == <span class="number">0</span> ? CacheResult.SUCCESS_WITHOUT_MSG :</span><br><span class="line">                failCount == map.size() ? CacheResult.FAIL_WITHOUT_MSG : CacheResult.PART_SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheResult</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RedisLettuceCache"><a href="#RedisLettuceCache" class="headerlink" title="RedisLettuceCache"></a>RedisLettuceCache</h5><blockquote>
<p>redis实现，使用lettuce客户端</p>
</blockquote>
<p>redis操作的lettuce客户端版本, 本文没啥好说的, 有时间写篇介绍lettuce.</p>
<blockquote>
<p>Jedis是直连模式，在多个线程间共享一个Jedis实例时是线程不安全的，可以通过创建多个Jedis实例来解决，但当连接数量增多时，物理连接成本就较高同时会影响性能，因此较好的解决方法是使用JedisPool。<br>Lettuce的连接是基于Netty的，连接实例可以在多个线程间共享，Netty可以使多线程的应用使用同一个连接实例，而不用担心并发线程的数量。通过异步的方式可以让我们更好地利用系统资源。</p>
</blockquote>
<h4 id="MultiLevelCache"><a href="#MultiLevelCache" class="headerlink" title="MultiLevelCache"></a>MultiLevelCache</h4><blockquote>
<p>多级缓存，注解方式配置只支持了两级，实际上这个类支持N级</p>
</blockquote>
<p>内部有个Cache数组, 从这里可以知道其是对Cache的包装, 并支持多个Cache, 子Cache不允许配置load</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MultiLevelCache</span><span class="params">(MultiLevelCacheConfig&lt;K, V&gt; cacheConfig)</span> <span class="keyword">throws</span> CacheConfigException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = cacheConfig;</span><br><span class="line">    <span class="built_in">this</span>.caches = cacheConfig.getCaches().toArray(<span class="keyword">new</span> <span class="title class_">Cache</span>[]&#123;&#125;);</span><br><span class="line">    checkCaches();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkCaches</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (caches == <span class="literal">null</span> || caches.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Cache c : caches) &#123;</span><br><span class="line">        <span class="comment">// 配置了会报错</span></span><br><span class="line">        <span class="keyword">if</span> (c.config().getLoader() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheConfigException</span>(<span class="string">&quot;Loader on sub cache is not allowed, set the loader into MultiLevelCache.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取数据时, 按照顺序从Cache数组中的各个元素中取, 如果上级没有命中, 下级命中了, 会有一个往上级同步的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CacheGetResult&lt;V&gt; <span class="title function_">do_GET</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; caches.length; i++) &#123;</span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> caches[i];</span><br><span class="line">        <span class="type">CacheGetResult</span> <span class="variable">result</span> <span class="operator">=</span> cache.GET(key);</span><br><span class="line">        <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">            CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder());</span><br><span class="line">            checkResultAndFillUpperCache(key, i, holder);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheGetResult</span>(CacheResultCode.SUCCESS, <span class="literal">null</span>, holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CacheGetResult.NOT_EXISTS_WITHOUT_MSG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i是索引, PUT_caches会插入i的所有上级Cache</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkResultAndFillUpperCache</span><span class="params">(K key, <span class="type">int</span> i, CacheValueHolder&lt;V&gt; h)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentExpire</span> <span class="operator">=</span> h.getExpireTime();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= currentExpire) &#123;</span><br><span class="line">        <span class="keyword">if</span>(config.isUseExpireOfSubCache())&#123;</span><br><span class="line">            PUT_caches(i, key, h.getValue(), <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">restTtl</span> <span class="operator">=</span> currentExpire - now;</span><br><span class="line">            <span class="keyword">if</span> (restTtl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PUT_caches(i, key, h.getValue(), restTtl, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个cache的put可能会某些成功,某些失败, 这里用到CompletableFuture的thenCombine进行结合, 如果发现结果码不同则返回半成功状态的ResultData</span></span><br><span class="line"><span class="comment">// lastIndex表示 更新lastIndex之前的所有缓存</span></span><br><span class="line"><span class="keyword">private</span> CacheResult <span class="title function_">PUT_caches</span><span class="params">(<span class="type">int</span> lastIndex, K key, V value, <span class="type">long</span> expire, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastIndex; i++) &#123;</span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> caches[i];</span><br><span class="line">        CacheResult r;</span><br><span class="line">        <span class="keyword">if</span> (timeUnit == <span class="literal">null</span>) &#123;</span><br><span class="line">            r = cache.PUT(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = cache.PUT(key, value, expire, timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        future = combine(future, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheResult</span>(future);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;ResultData&gt; <span class="title function_">combine</span><span class="params">(CompletableFuture&lt;ResultData&gt; future, CacheResult result)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> future.thenCombine(result.future(), (d1, d2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (d1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> d2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d1.getResultCode() != d2.getResultCode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultData</span>(CacheResultCode.PART_SUCCESS, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CacheResultCode.PART_SUCCESS 在 MultiLevelCache 下会出现, 表示操作多级缓存时, 某一部分没有操作成功</p>
</blockquote>
<p>MultiLevelCache的tryLock仅仅使用最后一级Cache的tryLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AutoReleaseLock <span class="title function_">tryLock</span><span class="params">(K key, <span class="type">long</span> expire, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> caches[caches.length - <span class="number">1</span>].tryLock(key, expire, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MultiLevelCache不支持putIfAbsent和do_PUT_IF_ABSENT方法, 会报错.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;putIfAbsent is not supported by MultiLevelCache&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CacheResult <span class="title function_">do_PUT_IF_ABSENT</span><span class="params">(K key, V value, <span class="type">long</span> expireAfterWrite, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;PUT_IF_ABSENT is not supported by MultiLevelCache&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProxyCache"><a href="#ProxyCache" class="headerlink" title="ProxyCache"></a>ProxyCache</h3><p>ProxyCache接口继承了Cache接口, 作用是代理Cache实现一些牛批的功能, 例如下面</p>
<h4 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a>LoadingCache</h4><blockquote>
<p>基于Decorator模式，提供自动加载功能</p>
</blockquote>
<p>主要是对get和getAll两个方法的处理, 如果配置了load, 这两方法将会在娶不到数据的时候自动load</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheInvokeException &#123;</span><br><span class="line">    CacheLoader&lt;K, V&gt; loader = config.getLoader();</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> AbstractCache.computeIfAbsentImpl(key, loader,</span><br><span class="line">                config.isCacheNullValue() ,<span class="number">0</span>, <span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没配置load不会报错, 而是走被包装cache的get</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;K, V&gt; <span class="title function_">getAll</span><span class="params">(Set&lt;? extends K&gt; keys)</span> <span class="keyword">throws</span> CacheInvokeException &#123;</span><br><span class="line">    CacheLoader&lt;K, V&gt; loader = config.getLoader();</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先取批量的结果</span></span><br><span class="line">        MultiGetResult&lt;K, V&gt; r = GET_ALL(keys);</span><br><span class="line">        Map&lt;K, V&gt; kvMap;</span><br><span class="line">        <span class="keyword">if</span> (r.isSuccess() || r.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 成功或者半成功取出 所有成功了的结果</span></span><br><span class="line">            kvMap = r.unwrapValues();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            kvMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出没有成功的key的集合, 这些需要被load</span></span><br><span class="line">        Set&lt;K&gt; keysNeedLoad = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        keys.forEach((k) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!kvMap.containsKey(k)) &#123;</span><br><span class="line">                keysNeedLoad.add(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 校验穿透保护开关</span></span><br><span class="line">        <span class="keyword">if</span> (!config.isCachePenetrationProtect()) &#123;</span><br><span class="line">            <span class="comment">// 直接找出需要update的Values, 一个PUT_ALL方法load进去</span></span><br><span class="line">            <span class="keyword">if</span> (eventConsumer != <span class="literal">null</span>) &#123;</span><br><span class="line">                loader = CacheUtil.createProxyLoader(cache, loader, eventConsumer);</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;K, V&gt; loadResult;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loadResult = loader.loadAll(keysNeedLoad);</span><br><span class="line"></span><br><span class="line">                CacheLoader&lt;K, V&gt; theLoader = loader;</span><br><span class="line">                Map&lt;K, V&gt; updateValues = loadResult.entrySet().stream()</span><br><span class="line">                        .filter(kvEntry -&gt; needUpdate(kvEntry.getValue(), theLoader))</span><br><span class="line">                        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// batch put</span></span><br><span class="line">                <span class="keyword">if</span> (!updateValues.isEmpty()) &#123;</span><br><span class="line">                    PUT_ALL(updateValues);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheInvokeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            kvMap.putAll(loadResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 循环keysNeedLoad, 依次调AbstractCache.synchronizedLoad方法来做同步load</span></span><br><span class="line">            AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">            loader = CacheUtil.createProxyLoader(cache, loader, eventConsumer);</span><br><span class="line">            <span class="keyword">for</span>(K key : keysNeedLoad) &#123;</span><br><span class="line">                Consumer&lt;V&gt; cacheUpdater = (v) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span>(needUpdate(v, config.getLoader())) &#123;</span><br><span class="line">                        PUT(key, v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> AbstractCache.synchronizedLoad(config, abstractCache, key, loader, cacheUpdater);</span><br><span class="line">                kvMap.put(key, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kvMap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.getAll(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RefreshCache"><a href="#RefreshCache" class="headerlink" title="RefreshCache"></a>RefreshCache</h4><blockquote>
<p>基于Decorator模式，提供自动刷新功能</p>
</blockquote>
<p>继承自LoadingCache, 即他的get和getAll能够自动load, 除此之外, 他自己做了这些工作:</p>
<p>使用ConcurrentHashMap维护了一个刷新任务集合, 为了方便批量操作,例如停止刷新, 并且用boolean字段标识代理的Cache是不是一个MultiLevelCache(多级缓存和单级的处理逻辑不一样,下面关注下)</p>
<p>RefreshCache同样也是对get和getAll做了增强, 添加了addOrUpdateRefreshTask的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheInvokeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.getRefreshPolicy() != <span class="literal">null</span> &amp;&amp; hasLoader()) &#123;</span><br><span class="line">        addOrUpdateRefreshTask(key, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;K, V&gt; <span class="title function_">getAll</span><span class="params">(Set&lt;? extends K&gt; keys)</span> <span class="keyword">throws</span> CacheInvokeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.getRefreshPolicy() != <span class="literal">null</span> &amp;&amp; hasLoader()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (K key : keys) &#123;</span><br><span class="line">            addOrUpdateRefreshTask(key, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getAll(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addOrUpdateRefreshTask 主要做了针对一个缓存的key, 创建一个RefreshTask任务, RefreshTask继承了Runnable, 它是个可被执行的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateRefreshTask</span><span class="params">(K key, CacheLoader&lt;K,V&gt; loader)</span> &#123;</span><br><span class="line">    <span class="comment">// 看看有没有配置刷新策略, 没有策略不会刷新, 这点注意别忘记配置了</span></span><br><span class="line">    <span class="type">RefreshPolicy</span> <span class="variable">refreshPolicy</span> <span class="operator">=</span> config.getRefreshPolicy();</span><br><span class="line">    <span class="keyword">if</span> (refreshPolicy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">refreshMillis</span> <span class="operator">=</span> refreshPolicy.getRefreshMillis();</span><br><span class="line">    <span class="comment">// 刷新时间不能小于等于0, 否则也不会刷新</span></span><br><span class="line">    <span class="keyword">if</span> (refreshMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">taskId</span> <span class="operator">=</span> getTaskId(key);</span><br><span class="line">        <span class="type">RefreshTask</span> <span class="variable">refreshTask</span> <span class="operator">=</span> taskMap.computeIfAbsent(taskId, tid -&gt; &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;add refresh task. interval=&#123;&#125;,  key=&#123;&#125;&quot;</span>, refreshMillis , key);</span><br><span class="line">            <span class="type">RefreshTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefreshTask</span>(taskId, key, loader);</span><br><span class="line">            task.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 有一个单例的线程池heavyIOExecutor, 定时处理task</span></span><br><span class="line">            ScheduledFuture&lt;?&gt; future = JetCacheExecutor.heavyIOExecutor().scheduleWithFixedDelay(</span><br><span class="line">                    task, refreshMillis, refreshMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            task.future = future;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 更新最后请求时间</span></span><br><span class="line">        refreshTask.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上可知道, 一个支持刷新的缓存, 只有get或者getAll方法调用后才会去启动刷新任务, 这样做避免了无谓的资源浪费, 即一个可刷新缓存被put后, 一直没有被获取, 那么他不会自动刷新.</p>
</blockquote>
<h5 id="具体的刷新逻辑"><a href="#具体的刷新逻辑" class="headerlink" title="具体的刷新逻辑"></a>具体的刷新逻辑</h5><p>RefreshTask的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有刷新策略或没有配置load不会跑任何load逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (config.getRefreshPolicy() == <span class="literal">null</span> || (loader == <span class="literal">null</span> &amp;&amp; !hasLoader())) &#123;</span><br><span class="line">            cancel();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">stopRefreshAfterLastAccessMillis</span> <span class="operator">=</span> config.getRefreshPolicy().getStopRefreshAfterLastAccessMillis();</span><br><span class="line">        <span class="comment">// 通过这个配置,如果一个key很久没有被请求了,超过阈值,停止刷新任务, 以免浪费资源</span></span><br><span class="line">        <span class="keyword">if</span> (stopRefreshAfterLastAccessMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastAccessTime + stopRefreshAfterLastAccessMillis &lt; now) &#123;</span><br><span class="line">                cancel();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是多级缓存, 会取最后一级缓存来更新, 最后一级缓存会驱动所有上级缓存更新.</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">concreteCache</span> <span class="operator">=</span> concreteCache();</span><br><span class="line">        <span class="keyword">if</span> (concreteCache <span class="keyword">instanceof</span> AbstractExternalCache) &#123;</span><br><span class="line">            <span class="comment">// 如果是三方</span></span><br><span class="line">            externalLoad(concreteCache, now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            load();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;refresh error: key=&quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalLoad</span><span class="params">(<span class="keyword">final</span> Cache concreteCache, <span class="keyword">final</span> <span class="type">long</span> currentTime)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 需要更新的缓存的key, 因为是三方的缓存, 所以要用buildKey生成</span></span><br><span class="line">    <span class="type">byte</span>[] newKey = ((AbstractExternalCache) concreteCache).buildKey(key);</span><br><span class="line">    <span class="comment">// 构建锁key</span></span><br><span class="line">    <span class="type">byte</span>[] lockKey = combine(newKey, <span class="string">&quot;_#RL#&quot;</span>.getBytes());</span><br><span class="line">    <span class="type">long</span> <span class="variable">loadTimeOut</span> <span class="operator">=</span> RefreshCache.<span class="built_in">this</span>.config.getRefreshPolicy().getRefreshLockTimeoutMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">refreshMillis</span> <span class="operator">=</span> config.getRefreshPolicy().getRefreshMillis();</span><br><span class="line">    <span class="comment">// 构建时间key</span></span><br><span class="line">    <span class="type">byte</span>[] timestampKey = combine(newKey, <span class="string">&quot;_#TS#&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractExternalCache buildKey method will not convert byte[]</span></span><br><span class="line">    <span class="type">CacheGetResult</span> <span class="variable">refreshTimeResult</span> <span class="operator">=</span> concreteCache.GET(timestampKey);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">shouldLoad</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (refreshTimeResult.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 当前时间 大于 刷新时间戳加刷新时间   表示很久没刷新了, 需要load一下, 否则不需要</span></span><br><span class="line">        shouldLoad = currentTime &gt;= Long.parseLong(refreshTimeResult.getValue().toString()) + refreshMillis;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refreshTimeResult.getResultCode() == CacheResultCode.NOT_EXISTS) &#123;</span><br><span class="line">        <span class="comment">// 第一次刷新, get不到refreshTimeResult 也需要load</span></span><br><span class="line">        shouldLoad = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要load</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldLoad) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiLevelCache) &#123;</span><br><span class="line">            <span class="comment">// 如果是多级缓存,需要刷新上级所有缓存</span></span><br><span class="line">            refreshUpperCaches(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个runable对象, 内部执行load, 并且load后刷新最后一次load时间到timestampKey</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load();</span><br><span class="line">            <span class="comment">// AbstractExternalCache buildKey method will not convert byte[]</span></span><br><span class="line">            concreteCache.put(timestampKey, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheException</span>(<span class="string">&quot;refresh error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractExternalCache buildKey method will not convert byte[]</span></span><br><span class="line">    <span class="comment">// 尝试获取锁, 并且执行加载操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lockSuccess</span> <span class="operator">=</span> concreteCache.tryLockAndRun(lockKey, loadTimeOut, TimeUnit.MILLISECONDS, r);</span><br><span class="line">    <span class="keyword">if</span>(!lockSuccess &amp;&amp; multiLevelCache) &#123;</span><br><span class="line">        <span class="comment">// 多级缓存如果没有load成功, 延迟一会会, 执行refreshUpperCaches刷新上级的缓存</span></span><br><span class="line">        <span class="comment">// 因为获取lockKey失败表示其他的实例可能在做refresh, 可能导致本地缓存错误, 延迟的目的是为了等待其他实例完成, 以免更新旧的值, </span></span><br><span class="line">        <span class="comment">// 如果refreshMillis配置有问题, 可能导致某些服务实例上的缓存有误差.</span></span><br><span class="line">        JetCacheExecutor.heavyIOExecutor().schedule(</span><br><span class="line">                () -&gt; refreshUpperCaches(key), (<span class="type">long</span>)(<span class="number">0.2</span> * refreshMillis), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 通过load来获取最新值, 然后PUT到对应的key中</span></span><br><span class="line">    CacheLoader&lt;K,V&gt; l = loader == <span class="literal">null</span>? config.getLoader(): loader;</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = CacheUtil.createProxyLoader(cache, l, eventConsumer);</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> l.load(key);</span><br><span class="line">        <span class="keyword">if</span> (needUpdate(v, l)) &#123;</span><br><span class="line">            cache.PUT(key, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CacheMonitor与CacheStat"><a href="#CacheMonitor与CacheStat" class="headerlink" title="CacheMonitor与CacheStat"></a>CacheMonitor与CacheStat</h2><p>CacheMonitor主要的作用是监听CacheEvent, jetCache实现了一个默认的CacheMonitor—–DefaultCacheMonitor;</p>
<p>DefaultCacheMonitor 里面包含了CacheStat的成员变量, CacheStat用来描述jetCache管理的缓存属性信息</p>
<p>一个Cache对应一个DefaultCacheMonitor, 一个DefaultCacheMonitor对应一个CacheStat, 每有个CacheEvent的发布, 都会通知到CacheMonitor, 并更新CacheStat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheStat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8802969946750554026L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String cacheName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> statStartTime;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> statEndTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getHitCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getMissCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getFailCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getExpireCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> getTimeSum;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">minGetTime</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">maxGetTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> putCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> putSuccessCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> putFailCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> putTimeSum;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">minPutTime</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">maxPutTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> removeCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> removeSuccessCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> removeFailCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> removeTimeSum;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">minRemoveTime</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">maxRemoveTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> loadCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> loadSuccessCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> loadFailCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> loadTimeSum;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">minLoadTime</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">maxLoadTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CacheMonitorManager"><a href="#CacheMonitorManager" class="headerlink" title="CacheMonitorManager"></a>CacheMonitorManager</h3><p>CacheMonitor的管理者, 使用者可以通过其添加自定义的Monitor, jetcache有个默认的实现DefaultCacheMonitorManager</p>
<p>对于多级缓存, DefaultCacheMonitorManager会新增两种Monitor</p>
<blockquote>
<p>针对多级缓存, DefaultCacheMonitorManager仅仅对前两个缓存做了监控.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMonitors</span><span class="params">(String area, String cacheName, Cache cache)</span> &#123;</span><br><span class="line">    <span class="comment">// MetricsMonitor</span></span><br><span class="line">    addMetricsMonitor(area, cacheName, cache);</span><br><span class="line">    <span class="comment">// CacheUpdateMonitor</span></span><br><span class="line">    addCacheUpdateMonitor(area, cacheName, cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addMetricsMonitor</span><span class="params">(String area, String cacheName, Cache cache)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultMetricsManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        cache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">        <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> MultiLevelCache) &#123;</span><br><span class="line">            <span class="type">MultiLevelCache</span> <span class="variable">mc</span> <span class="operator">=</span> (MultiLevelCache) cache;</span><br><span class="line">            <span class="keyword">if</span> (mc.caches().length == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 仅仅监控前面俩, 如果三级或更多, 不会有CacheMonitor</span></span><br><span class="line">                <span class="type">Cache</span> <span class="variable">local</span> <span class="operator">=</span> mc.caches()[<span class="number">0</span>];</span><br><span class="line">                <span class="type">Cache</span> <span class="variable">remote</span> <span class="operator">=</span> mc.caches()[<span class="number">1</span>];</span><br><span class="line">                <span class="type">DefaultCacheMonitor</span> <span class="variable">localMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCacheMonitor</span>(cacheName + <span class="string">&quot;_local&quot;</span>);</span><br><span class="line">                local.config().getMonitors().add(localMonitor);</span><br><span class="line">                <span class="type">DefaultCacheMonitor</span> <span class="variable">remoteMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCacheMonitor</span>(cacheName + <span class="string">&quot;_remote&quot;</span>);</span><br><span class="line">                remote.config().getMonitors().add(remoteMonitor);</span><br><span class="line">                defaultMetricsManager.add(localMonitor, remoteMonitor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有个默认的CacheMonitor</span></span><br><span class="line">        <span class="type">DefaultCacheMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCacheMonitor</span>(cacheName);</span><br><span class="line">        cache.config().getMonitors().add(monitor);</span><br><span class="line">        defaultMetricsManager.add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以自己实现 cacheMessagePublisher 把缓存的事件发布到其他地方去</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCacheUpdateMonitor</span><span class="params">(String area, String cacheName, Cache cache)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheMessagePublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">CacheMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> CachePutEvent) &#123;</span><br><span class="line">                <span class="type">CacheMessage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheMessage</span>();</span><br><span class="line">                <span class="type">CachePutEvent</span> <span class="variable">e</span> <span class="operator">=</span> (CachePutEvent) event;</span><br><span class="line">                m.setType(CacheMessage.TYPE_PUT);</span><br><span class="line">                m.setKeys(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;e.getKey()&#125;);</span><br><span class="line">                cacheMessagePublisher.publish(area, cacheName, m);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> CacheRemoveEvent) &#123;</span><br><span class="line">                <span class="type">CacheMessage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheMessage</span>();</span><br><span class="line">                <span class="type">CacheRemoveEvent</span> <span class="variable">e</span> <span class="operator">=</span> (CacheRemoveEvent) event;</span><br><span class="line">                m.setType(CacheMessage.TYPE_REMOVE);</span><br><span class="line">                m.setKeys(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;e.getKey()&#125;);</span><br><span class="line">                cacheMessagePublisher.publish(area, cacheName, m);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> CachePutAllEvent) &#123;</span><br><span class="line">                <span class="type">CacheMessage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheMessage</span>();</span><br><span class="line">                <span class="type">CachePutAllEvent</span> <span class="variable">e</span> <span class="operator">=</span> (CachePutAllEvent) event;</span><br><span class="line">                m.setType(CacheMessage.TYPE_PUT_ALL);</span><br><span class="line">                <span class="keyword">if</span> (e.getMap() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    m.setKeys(e.getMap().keySet().toArray());</span><br><span class="line">                &#125;</span><br><span class="line">                cacheMessagePublisher.publish(area, cacheName, m);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> CacheRemoveAllEvent) &#123;</span><br><span class="line">                <span class="type">CacheMessage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheMessage</span>();</span><br><span class="line">                <span class="type">CacheRemoveAllEvent</span> <span class="variable">e</span> <span class="operator">=</span> (CacheRemoveAllEvent) event;</span><br><span class="line">                m.setType(CacheMessage.TYPE_REMOVE_ALL);</span><br><span class="line">                <span class="keyword">if</span> (e.getKeys() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    m.setKeys(e.getKeys().toArray());</span><br><span class="line">                &#125;</span><br><span class="line">                cacheMessagePublisher.publish(area, cacheName, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cache.config().getMonitors().add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DefaultMetricsManager"><a href="#DefaultMetricsManager" class="headerlink" title="DefaultMetricsManager"></a>DefaultMetricsManager</h3><blockquote>
<p>默认的指标监控器</p>
</blockquote>
<p>内部有个CopyOnWriteArrayList来保存需要监控的DefaultCacheMonitor, 有个ScheduledFuture用来定时扫描DefaultCacheMonitor, 可以通过参数resetTime和resetTimeUnit调整ScheduledFuture的执行间隔. 并且有个Consumer,用来定义如何处理每个缓存中的CacheStat信息, 默认的处理方式是StatInfoLogger,即日志打印出来. jetCache可以定时打印日志, 公布缓存使用情况.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMetricsManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DefaultMetricsManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> CopyOnWriteArrayList&lt; DefaultCacheMonitor&gt; monitorList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> resetTime;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit resetTimeUnit;</span><br><span class="line">    <span class="keyword">private</span> Consumer&lt;StatInfo&gt; metricsCallback;</span><br><span class="line">    <span class="comment">// ... 省略某些方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个&quot;根据monitorList来构造一个StatInfo, 最终Consumer来处理&quot;的run流程</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;CacheStat&gt; stats = monitorList.stream().map((m) -&gt; &#123;</span><br><span class="line">                    <span class="type">CacheStat</span> <span class="variable">stat</span> <span class="operator">=</span> m.getCacheStat();</span><br><span class="line">                    m.resetStat();</span><br><span class="line">                    <span class="keyword">return</span> stat;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="type">StatInfo</span> <span class="variable">statInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatInfo</span>();</span><br><span class="line">                statInfo.setStartTime(time);</span><br><span class="line">                statInfo.setEndTime(endTime);</span><br><span class="line">                statInfo.setStats(stats);</span><br><span class="line">                time = endTime;</span><br><span class="line"></span><br><span class="line">                metricsCallback.accept(statInfo);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;jetcache DefaultMetricsManager error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 开始执行周期性定时任务</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> firstDelay(resetTime, resetTimeUnit);</span><br><span class="line">        future = JetCacheExecutor.defaultExecutor().scheduleAtFixedRate(</span><br><span class="line">                cmd, delay, resetTimeUnit.toMillis(resetTime), TimeUnit.MILLISECONDS);</span><br><span class="line">        logger.info(<span class="string">&quot;cache stat period at &quot;</span> + resetTime + <span class="string">&quot; &quot;</span> + resetTimeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略某些方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与Spring的对接"><a href="#与Spring的对接" class="headerlink" title="与Spring的对接"></a>与Spring的对接</h3><p>jetcache继承了AbstractLifecycle并实现了Spring的ApplicationContextAware, 启动时将会自动执行<code>onInit()</code>方法, <code>onInit()</code>方法将会执行<code>initDefaultCacheMonitorInstaller</code>传入默认的<code>metricsCallback</code>(就是个<code>StatInfoLogger</code>), 并执行init方法, DefaultCacheMonitorManager中的DefaultMetricsManager将会被<code>start()</code>, <code>start()</code>内会启动一个周期性定时线程池来扫描<code>DefaultCacheMonitor</code>中的<code>CacheStat</code>, 最后转化成<code>StatInfo</code>, 交给<code>metricsCallback</code>去处理.</p>
<p>上图:</p>
<p><img src="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224344.png" alt="screenshot-20210410-224344.png"></p>
<p><img src="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224436.png" alt="screenshot-20210410-224436.png"></p>
<p><img src="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224459.png" alt="screenshot-20210410-224459.png"></p>
<p><img src="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224543.png" alt="sscreenshot-20210410-224543.png"></p>
<p><img src="https://shanghai-yuda-test.oss-cn-shanghai.aliyuncs.com/images/210410/screenshot-20210410-224626.png" alt="sscreenshot-20210410-224626.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.canyuda.top/posts/2021040542562/" data-id="clsbfdtqb0095ewol1cr1fcd3" data-title="JetCache的源码" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cache/" rel="tag">缓存</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/2021102638891/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          通讯协议之ModBus
        
      </div>
    </a>
  
  
    <a href="/posts/2021040520009/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">JetCache的使用</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/industrial-control/">工业控制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structures-algorithms/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/" rel="tag">Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Web/" rel="tag">Java Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/" rel="tag">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">Spring-Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/myporject/" rel="tag">个人项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offer-book/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chart/" rel="tag">图表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tips/" rel="tag">小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort-and-find/" rel="tag">排序与查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/search/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/authority/" rel="tag">权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/catalogue/" rel="tag">目录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plan/" rel="tag">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-mode/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/communication-protocol/" rel="tag">通讯协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hystrix/" style="font-size: 10.91px;">Hystrix</a> <a href="/tags/jvm/" style="font-size: 16.36px;">JVM</a> <a href="/tags/Java-Web/" style="font-size: 13.64px;">Java Web</a> <a href="/tags/mybatis/" style="font-size: 10.91px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 10.91px;">MySQL</a> <a href="/tags/oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/spring/" style="font-size: 17.27px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/spring-cloud/" style="font-size: 10.91px;">Spring-Cloud</a> <a href="/tags/myporject/" style="font-size: 14.55px;">个人项目</a> <a href="/tags/offer-book/" style="font-size: 18.18px;">剑指offer</a> <a href="/tags/chart/" style="font-size: 15.45px;">图表</a> <a href="/tags/base/" style="font-size: 20px;">基础</a> <a href="/tags/tips/" style="font-size: 13.64px;">小知识</a> <a href="/tags/sort-and-find/" style="font-size: 12.73px;">排序与查找</a> <a href="/tags/search/" style="font-size: 10px;">搜索</a> <a href="/tags/authority/" style="font-size: 10px;">权限</a> <a href="/tags/catalogue/" style="font-size: 11.82px;">目录</a> <a href="/tags/cache/" style="font-size: 10.91px;">缓存</a> <a href="/tags/plan/" style="font-size: 11.82px;">计划</a> <a href="/tags/design-mode/" style="font-size: 19.09px;">设计模式</a> <a href="/tags/communication-protocol/" style="font-size: 10px;">通讯协议</a> <a href="/tags/concurrent/" style="font-size: 12.73px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/2022113049586/">索引下推</a>
          </li>
        
          <li>
            <a href="/posts/2022112963116/">Explain详解</a>
          </li>
        
          <li>
            <a href="/posts/2022091136394/">分布式系统（十一）</a>
          </li>
        
          <li>
            <a href="/posts/2022091023774/">分布式系统（十）</a>
          </li>
        
          <li>
            <a href="/posts/2022090955657/">分布式系统（九）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 灿若繁星先生<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>