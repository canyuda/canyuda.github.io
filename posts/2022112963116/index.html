<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Explain详解 | 灿若繁星</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="当Explain 与 SQL语句一起使用时，MySQL 会显示来自优化器关于SQL执行的信息。也就是说，MySQL解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。  表的加载顺序 sql 的查询类型 可能用到哪些索引，哪些索引又被实际使用 表与表之间的引用关系 一个表中有多少行被优化器查询 …..">
<meta property="og:type" content="article">
<meta property="og:title" content="Explain详解">
<meta property="og:url" content="http://blog.canyuda.top/posts/2022112963116/index.html">
<meta property="og:site_name" content="灿若繁星">
<meta property="og:description" content="当Explain 与 SQL语句一起使用时，MySQL 会显示来自优化器关于SQL执行的信息。也就是说，MySQL解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。  表的加载顺序 sql 的查询类型 可能用到哪些索引，哪些索引又被实际使用 表与表之间的引用关系 一个表中有多少行被优化器查询 …..">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-29T02:12:09.000Z">
<meta property="article:modified_time" content="2022-11-29T02:19:52.863Z">
<meta property="article:author" content="灿若繁星先生">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="灿若繁星" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">灿若繁星</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人空间</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.canyuda.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Explain详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/2022112963116/" class="article-date">
  <time class="dt-published" datetime="2022-11-29T02:12:09.000Z" itemprop="datePublished">2022-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/database/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Explain详解
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>当Explain 与 SQL语句一起使用时，MySQL 会显示来自优化器关于SQL执行的信息。也就是说，MySQL解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。</p>
<ul>
<li>表的加载顺序</li>
<li>sql 的查询类型</li>
<li>可能用到哪些索引，哪些索引又被实际使用</li>
<li>表与表之间的引用关系</li>
<li>一个表中有多少行被优化器查询 …..</li>
</ul>
<span id="more"></span>

<p>Explain 执行计划包含字段信息如下：分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra 12个字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h2 id="各个字段"><a href="#各个字段" class="headerlink" title="各个字段"></a>各个字段</h2><table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td>
</tr>
<tr>
<td><code>select_type</code></td>
<td><code>SELECT</code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td><code>table</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>partitions</code></td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td><code>type</code></td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td><code>possible_keys</code></td>
<td>可能用到的索引</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td><code>filtered</code></td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>id： ：表示查询中执行select子句或者操作表的顺序，id的值越大，代表优先级越高，越先执行。id大致会出现 3种情况：</p>
<h4 id="1、id相同"><a href="#1、id相同" class="headerlink" title="1、id相同"></a>1、id相同</h4><p>看到三条记录的id都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                 |    2 |       50 | Using <span class="built_in">where</span>; Using <span class="built_in">join</span> buffer (Block Nested Loop) |</span><br><span class="line">|  1 | SIMPLE      | r     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.t.three_id |    1 |      100 | NULL                                               |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="2、id不同"><a href="#2、id不同" class="headerlink" title="2、id不同"></a>2、id不同</h4><p>如果我们的 SQL 中存在子查询，那么 id的序号会递增，id值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 id最大，最先执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> * from one o <span class="built_in">where</span> o.two_id = (<span class="keyword">select</span> t.two_id from two t <span class="built_in">where</span> t.three_id = (<span class="keyword">select</span> r.three_id  from three r <span class="built_in">where</span> r.three_name=<span class="string">&#x27;我是第三表2&#x27;</span>));</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="3、以上两种同时存在"><a href="#3、以上两种同时存在" class="headerlink" title="3、以上两种同时存在"></a>3、以上两种同时存在</h4><p>将上边的 SQL 稍微修改一下，增加一个子查询，发现 id的以上两种同时存在。相同id划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 id值越大，优先级越高，越先执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN <span class="keyword">select</span> * from one o <span class="built_in">where</span> o.two_id = (<span class="keyword">select</span> t.two_id from two t <span class="built_in">where</span> t.three_id = (<span class="keyword">select</span> r.three_id  from three r <span class="built_in">where</span> r.three_name=<span class="string">&#x27;我是第三表2&#x27;</span>)) AND o.one_id <span class="keyword">in</span>(<span class="keyword">select</span> one_id from one <span class="built_in">where</span> o.one_name=<span class="string">&quot;我是第一表2&quot;</span>);</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>   | possible_keys | key     | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">|  1 | PRIMARY     | one   | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type：表示 select 查询的类型，主要是用于区分各种复杂的查询，例如：普通查询、联合查询、子查询等。</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 union交并差集等操作。</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>当查询语句中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>当 select 或 where 列表中包含了子查询，该子查询被标记为：SUBQUERY 。</td>
</tr>
<tr>
<td>DERIVED</td>
<td>表示包含在from子句中的子查询的select，在我们的 from 列表中包含的子查询会被标记为derived 。</td>
</tr>
<tr>
<td>UNION</td>
<td>如果union后边又出现的select 语句，则会被标记为union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived。</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>代表从union的临时表中读取数据，而table列的表示用第一个和第四个select的结果进行union操作。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> t.two_name, ( <span class="keyword">select</span> one.one_id from one) o from (<span class="keyword">select</span> two_id,two_name from two <span class="built_in">where</span> two_name =<span class="string">&#x27;&#x27;</span>) t  union (<span class="keyword">select</span> r.three_name,r.three_id from three r);</span><br><span class="line"></span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| <span class="built_in">id</span>   | select_type  | table      | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | two        | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |       50 | Using <span class="built_in">where</span>     |</span><br><span class="line">|    2 | SUBQUERY     | one        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |      100 | Using index     |</span><br><span class="line">|    4 | UNION        | r          | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |      100 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,4&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL | NULL     | Using temporary |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br></pre></td></tr></table></figure>

<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的DERIVED、 等。</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表时，partitions显示分区表命中的分区情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table          | partitions                      | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one            | p201801,p201802,p201803,p300012 | index | NULL          | PRIMARY | 9       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type：查询使用了何种类型，它在 SQL优化中是一个非常重要的指标，以下性能从好到坏依次是：<strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>ref_or_null</strong> &gt; <strong>index_merge</strong> &gt; <strong>unique_subquery</strong> &gt; <strong>index_subquery</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p>当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three <span class="built_in">where</span> three_id=1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><p>查询时命中主键primary key 或者 unique key索引， type 就是 eq_ref。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> o.one_name from one o ,two t <span class="built_in">where</span> o.one_id = t.two_id ; </span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>   | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index  | PRIMARY       | idx_name | 768     | NULL               |    2 |      100 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY  | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>区别于eq_ref ，ref表示使用非唯一性索引，会找到很多个符合条件的行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> o.one_id from one o <span class="built_in">where</span> o.one_name = <span class="string">&quot;xin&quot;</span> ; </span><br><span class="line">+--------+</span><br><span class="line">| one_id |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      3 |</span><br><span class="line">+--------+sql</span><br><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> o.one_id from one o <span class="built_in">where</span> o.one_name = <span class="string">&quot;xin&quot;</span> ; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h4><p>这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> o.one_id from one o <span class="built_in">where</span> o.one_name = <span class="string">&quot;xin&quot;</span> OR o.one_name IS NULL; </span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref_or_null | idx_name      | idx_name | 768     | const |    3 |      100 | Using <span class="built_in">where</span>; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h4><p>使用了索引合并优化方法，查询使用了两个以上的索引。<br>下边示例中同时使用到主键one_id 和 字段one_name的idx_name 索引 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> * from one o <span class="built_in">where</span> o.one_id &gt;1 and o.one_name =<span class="string">&#x27;xin&#x27;</span>; </span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index_merge | PRIMARY,idx_name | idx_name,PRIMARY | 772,4   | NULL |    1 |      100 | Using intersect(idx_name,PRIMARY); Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h4><p>替换下面的 IN子查询，子查询返回不重复的集合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (SELECT primary_key FROM single_table WHERE some_expr)</span><br></pre></td></tr></table></figure>

<h4 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h4><p>区别于unique_subquery，用于非唯一索引，可以返回重复值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (SELECT key_column FROM single_table WHERE some_expr)</span><br></pre></td></tr></table></figure>

<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 type 都是 range。<br>举个栗子：three表中three_id为唯一主键，user_id普通字段未建索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three <span class="built_in">where</span> three_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |      100 | Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<p>从结果中看到只有对设置了索引的字段，做范围检索 type 才是 range。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three <span class="built_in">where</span> user_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。</p>
<p>下边示例：three_id 为主键，不带 where 条件全表查询 ，type结果为index 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT three_id from three ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>将遍历全表以找到匹配的行，性能最差。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from two ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | two   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>表示在MySQL中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>区别于possible_keys，key是查询中实际使用到的索引，若没有使用索引，显示为NULL。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询用到的索引长度（字节数），原则上长度越短越好 。</p>
<ul>
<li>单列索引，那么需要将整个索引长度算进去；</li>
<li>多列索引，不是所有列都能用到，需要计算查询中实际用到的列。</li>
</ul>
<blockquote>
<p>注意：key_len只计算where条件中用到的索引长度，而排序(order by)和分组(group by)即便是用到了索引，也不会计算到key_len中。</p>
</blockquote>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p>常见的有：<code>const</code>，<code>func</code>，<code>null</code>，<code>字段名</code>。</p>
<ul>
<li>当使用常量等值查询，显示const，</li>
<li>当关联查询时，会显示相应关联表的关联字段</li>
<li>如果查询条件使用了表达式、函数，或者条件列发生内部隐式转换，可能显示为func</li>
<li>其他情况null</li>
</ul>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</p>
<p>这是评估SQL 性能的一个比较重要的数据，mysql需要扫描的行数，很直观的显示 SQL 性能的好坏，一般情况下 rows 值越小越好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>filtered 这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p>
<p>在MySQL.5.7版本以前想要显示filtered需要使用explain extended命令。MySQL.5.7后，默认explain直接显示partitions和filtered的信息。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>不适合在其他列中显示的信息，Explain 中的很多额外的信息会在 Extra 字段显示。</p>
<h4 id="1、Using-index"><a href="#1、Using-index" class="headerlink" title="1、Using index"></a>1、Using index</h4><p>Using index：我们在相应的 select 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，SQl优化中理想的状态。</p>
<h5 id="什么又是覆盖索引"><a href="#什么又是覆盖索引" class="headerlink" title="什么又是覆盖索引?"></a>什么又是覆盖索引?</h5><p>一条 SQL只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引，查到主键之后再通过主键查询整行数据（select * ）。</p>
<p>one_id表为主键</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | idx_two_id | 5       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：想要使用到覆盖索引，我们在 select 时只取出需要的字段，不可select *，而且该字段建了索引。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from one ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h4 id="2、Using-where"><a href="#2、Using-where" class="headerlink" title="2、Using where"></a>2、Using where</h4><p>查询时未找到可用的索引，进而通过where条件过滤获取所需数据，但要注意的是并不是所有带where语句的查询都会显示Using where。</p>
<p>下边示例create_time 并未用到索引，type 为 ALL，即MySQL通过全表扫描后再按where条件筛选数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one <span class="built_in">where</span> create_time =<span class="string">&#x27;2020-05-18&#x27;</span>;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using <span class="built_in">where</span> |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h4><p>表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one <span class="built_in">where</span> one_id <span class="keyword">in</span> (1,2) group by one_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | range| NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using <span class="built_in">where</span>; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="4、Using-filesort"><a href="#4、Using-filesort" class="headerlink" title="4、Using filesort"></a>4、Using filesort</h4><p>表示无法利用索引完成的排序操作，也就是ORDER BY的字段没有索引，通常这样的SQL都是需要优化的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果ORDER BY字段有索引就会用到覆盖索引，相比执行速度快很多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="5、Using-join-buffer"><a href="#5、Using-join-buffer" class="headerlink" title="5、Using join buffer"></a>5、Using join buffer</h4><p>在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。<br>先看一下有索引的情况：连接条件 one_name 、two_name 都用到索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t <span class="built_in">where</span> o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key      | key_len | ref                  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index | idx_name      | idx_name | 768     | NULL                 |    3 |      100 | Using <span class="built_in">where</span>; Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ref   | idx_name      | idx_name | 768     | xin-slave.o.one_name |    1 |      100 | Using index              |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br></pre></td></tr></table></figure>

<p>接下来删掉 连接条件 <code>one_name</code> 、<code>two_name</code> 的字段索引。发现Extra 列变成 <code>Using join buffer</code>，<code>type</code>均为全表扫描，这也是SQL优化中需要注意的地方。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t <span class="built_in">where</span> o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using <span class="built_in">where</span>; Using <span class="built_in">join</span> buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="6、Impossible-where"><a href="#6、Impossible-where" class="headerlink" title="6、Impossible where"></a>6、Impossible where</h4><p>表示在我们用不太正确的where语句，导致没有符合条件的行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one WHERE 1=2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | Impossible WHERE |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br></pre></td></tr></table></figure>

<h4 id="7、No-tables-used"><a href="#7、No-tables-used" class="headerlink" title="7、No tables used"></a>7、No tables used</h4><p>我们的查询语句中没有FROM子句，或者有 FROM DUAL子句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN <span class="keyword">select</span> now();</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| <span class="built_in">id</span> | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上边只是简单介绍了下 Explain 执行计划各个列的含义，了解它不仅仅是要应付面试，在实际开发中也经常会用到。比如对慢SQL进行分析，如果连执行计划结果都不会看，那还谈什么SQL优化呢？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.canyuda.top/posts/2022112963116/" data-id="clsbfozfq00caigol4f8zb0p5" data-title="Explain详解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/2022113049586/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          索引下推
        
      </div>
    </a>
  
  
    <a href="/posts/2022091136394/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">分布式系统（十一）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/industrial-control/">工业控制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-structures-algorithms/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/" rel="tag">Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Web/" rel="tag">Java Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/" rel="tag">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">Spring-Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/myporject/" rel="tag">个人项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offer-book/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chart/" rel="tag">图表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tips/" rel="tag">小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort-and-find/" rel="tag">排序与查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/search/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/authority/" rel="tag">权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/catalogue/" rel="tag">目录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plan/" rel="tag">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-mode/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/communication-protocol/" rel="tag">通讯协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hystrix/" style="font-size: 10.91px;">Hystrix</a> <a href="/tags/jvm/" style="font-size: 16.36px;">JVM</a> <a href="/tags/Java-Web/" style="font-size: 13.64px;">Java Web</a> <a href="/tags/mybatis/" style="font-size: 10.91px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 10.91px;">MySQL</a> <a href="/tags/oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/spring/" style="font-size: 17.27px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/spring-cloud/" style="font-size: 10.91px;">Spring-Cloud</a> <a href="/tags/myporject/" style="font-size: 14.55px;">个人项目</a> <a href="/tags/offer-book/" style="font-size: 18.18px;">剑指offer</a> <a href="/tags/chart/" style="font-size: 15.45px;">图表</a> <a href="/tags/base/" style="font-size: 20px;">基础</a> <a href="/tags/tips/" style="font-size: 13.64px;">小知识</a> <a href="/tags/sort-and-find/" style="font-size: 12.73px;">排序与查找</a> <a href="/tags/search/" style="font-size: 10px;">搜索</a> <a href="/tags/authority/" style="font-size: 10px;">权限</a> <a href="/tags/catalogue/" style="font-size: 11.82px;">目录</a> <a href="/tags/cache/" style="font-size: 10.91px;">缓存</a> <a href="/tags/plan/" style="font-size: 11.82px;">计划</a> <a href="/tags/design-mode/" style="font-size: 19.09px;">设计模式</a> <a href="/tags/communication-protocol/" style="font-size: 10px;">通讯协议</a> <a href="/tags/concurrent/" style="font-size: 12.73px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/2022113049586/">索引下推</a>
          </li>
        
          <li>
            <a href="/posts/2022112963116/">Explain详解</a>
          </li>
        
          <li>
            <a href="/posts/2022091136394/">分布式系统（十一）</a>
          </li>
        
          <li>
            <a href="/posts/2022091023774/">分布式系统（十）</a>
          </li>
        
          <li>
            <a href="/posts/2022090955657/">分布式系统（九）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 灿若繁星先生<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>